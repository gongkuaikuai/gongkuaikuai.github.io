###### 概念1
- 并发（concurrency）：一个同时有多个活动的系统。
- 并行（parallelism）：用并发来使一个系统运行的更快。
- 原语（primitive or atomic action）：是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性。
- 临界区（critical region/section）: 把对共享内存进行访问的程序片段，称为临界区。
- 数据竞争（Data Race）：当多个线程访问同一数据，并且至少有一个线程会写这个数据的事后，如果不做防护措施，那就会导致并发Bug。这就叫数据竞争。
- 竞争条件（race condition）：
  - 定义1:两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。*翻译成竞争场景是不是更合理*
  - 定义2（极客时间版）:程序的执行结果依赖线程的执行顺序。
  - 辅助理解：程序的执行依赖于某个状态变量，当某个线程发现状态变量满足执行条件后，开始执行操作。可是就在这个线程执行操作的时候，其他线程同时修改了状态变量，导致状态变量不满足执行条件了。
- 互斥（mutual exclusion）
- 忙等待（busy waiting）：连续测试一个变量直到某个值出现，称为忙等待。
- 锁变量：一个共享（锁）变量。
- 自旋锁（spin lock）：用于忙等待的锁，称为自旋锁。
- 有界缓冲区问题（bounded-buffer）：即生产者消费者问题。
- 唤醒等待位：wakeup信号的小仓库。
- 信号量（semaphore）：用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行，初始化、递减和增加。三种操作都是原子的。递减可以阻塞一个进程，增加可以解除阻塞一个进程。也称为计数信号量或一般信号量。
  - **原始版本是P和V，P为Proberen（测试），V为Verhogen（增加）**
- 二元信号量：只取0和1的信号量。
- 互斥量（mutex）：类似于二元信号量。区别在于为其加锁的进程和为其解锁的进行必须为同一进程。
- 条件变量：一种数据类型，用于阻塞进程或者线程，直到特定的条件完成。
- 管程（monitor）：在一个抽象数据类型中封装了变量、访问过程及初始化代码。管程的变量只能由管程自己的访问过程来访问，每次只能由一个进程在其中执行。访问过程即临界区。管程可以有一个等待进程队列。
- 线程安全：
  - 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，夜不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

###### 概念2
- 超线程：有时称为 *同时多线程（simultanious multi-threading）*，是一项允许一个CPU执行多个控制流的技术。它设计CPU的一部分硬件有多个备份，比如程序计数器、寄存器，而其他的硬件部分只有一份，比如执行浮点运算的单元。
- 指令级并行：现代处理器可以同时执行多条指令的属性，称为指令级并行。当前每个时钟周期可执行2～4条指令。
- 单指令、多数据并行：许多现代处理器拥有特殊硬件，允许一条指令产生多个可以并行执行的操作。
- 流水线（pipelining）：在流水线中，将一条执行所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。（*？类似于指令重排序*）
- 指令重排序：CPU采用了允许将多条指令不按程序规定的顺序分开发送给响应电路单元处理。
- 线程五状态模型：运行态、就绪态、阻塞／等待态、新建态、退出态。*与Java线程六状态不同，Java是New、Runnable、Blocked、Waiting、Timed-waiting、Terminated*


###### 理解
- 进程通信三问题：（和极客时间老师说的说一回事）
  1. 一个进程如何把信息传递给另一个。（分工）
  1. 确保两个或多个进程在关键活动中不会出现交叉。（互斥）
  1. 正确的顺序。（同步）
- 并发编程涉及的微观宏观问题
  - 微观：原子性、可见性、有序性
  - 宏观：安全性、活跃性、性能
    - 活跃性问题：
      1. 死锁：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。
      1. 活锁：有时线程虽然没有发生阻塞，但仍然存在执行不下去但情况，就是活锁。
      1. 饥饿：线程无法访问所需资源而无法执行下去的情况。
    - 性能三指标
      1. 吞吐量：单位时间内能处理的请求数量
      1. 延迟：从发出请求到收到响应的时间        
      1. 并发量：能同时处理的请求数量。随着并发量增加，延迟也会增加。所以延迟一般都是基于并发量来说的。


###### 其他知识点
- 常规处理器需要20000个时钟周期进行线程切换。

###### 感悟
- 从竞争条件的定义就可以了解到解决办法。避免共享数据，或者精确控制顺序。
- 其实编程语言好。它对管程对支持就很重要。

###### 问题
- 指令重排序和流水线的关系
- 引用逃逸
- 内存屏障
- 原语和Java的Atomic类有啥关系？
- nio的方式，依然会导致有一个线程是忙等待的，有支持异步的了吗？
